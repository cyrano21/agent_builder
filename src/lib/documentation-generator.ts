import { aiModelService } from './ai-models';
import { ModelSelection } from './ai-models';

export interface DocumentationSection {
  title: string;
  content: string;
  type: 'readme' | 'api' | 'architecture' | 'deployment' | 'testing' | 'contributing';
  priority: 'high' | 'medium' | 'low';
}

export interface TestFile {
  fileName: string;
  content: string;
  type: 'unit' | 'integration' | 'e2e';
  framework: 'jest' | 'cypress' | 'playwright';
  coverage: number;
}

export interface DocumentationPackage {
  project: {
    name: string;
    description: string;
    version: string;
    author: string;
  };
  sections: DocumentationSection[];
  testFiles: TestFile[];
  generatedAt: string;
  modelUsed: string;
}

export class DocumentationGenerator {
  static async generateCompleteDocumentation(
    projectData: {
      name: string;
      description: string;
      techStack: string[];
      features: string[];
      architecture?: string;
    },
    modelSelection: ModelSelection,
    onProgress?: (progress: string) => void
  ): Promise<DocumentationPackage> {
    const sections: DocumentationSection[] = [];
    const testFiles: TestFile[] = [];

    if (onProgress) onProgress('Génération de la documentation README...');

    // 1. Generate README.md
    const readmeContent = await this.generateReadme(projectData, modelSelection);
    sections.push({
      title: 'README.md',
      content: readmeContent,
      type: 'readme',
      priority: 'high'
    });

    if (onProgress) onProgress('Génération de la documentation API...');

    // 2. Generate API Documentation
    const apiContent = await this.generateAPIDocumentation(projectData, modelSelection);
    sections.push({
      title: 'API Documentation',
      content: apiContent,
      type: 'api',
      priority: 'high'
    });

    if (onProgress) onProgress('Génération de la documentation architecture...');

    // 3. Generate Architecture Documentation
    const archContent = await this.generateArchitectureDocumentation(projectData, modelSelection);
    sections.push({
      title: 'Architecture Documentation',
      content: archContent,
      type: 'architecture',
      priority: 'medium'
    });

    if (onProgress) onProgress('Génération de la documentation déploiement...');

    // 4. Generate Deployment Documentation
    const deployContent = await this.generateDeploymentDocumentation(projectData, modelSelection);
    sections.push({
      title: 'Deployment Guide',
      content: deployContent,
      type: 'deployment',
      priority: 'medium'
    });

    if (onProgress) onProgress('Génération des tests unitaires...');

    // 5. Generate Unit Tests
    const unitTests = await this.generateUnitTests(projectData, modelSelection);
    testFiles.push(...unitTests);

    if (onProgress) onProgress('Génération des tests d\'intégration...');

    // 6. Generate Integration Tests
    const integrationTests = await this.generateIntegrationTests(projectData, modelSelection);
    testFiles.push(...integrationTests);

    if (onProgress) onProgress('Génération des tests E2E...');

    // 7. Generate E2E Tests
    const e2eTests = await this.generateE2ETests(projectData, modelSelection);
    testFiles.push(...e2eTests);

    if (onProgress) onProgress('Génération du guide de contribution...');

    // 8. Generate Contributing Guide
    const contributingContent = await this.generateContributingGuide(projectData, modelSelection);
    sections.push({
      title: 'Contributing Guide',
      content: contributingContent,
      type: 'contributing',
      priority: 'low'
    });

    return {
      project: {
        name: projectData.name,
        description: projectData.description,
        version: '1.0.0',
        author: 'Generated by AI'
      },
      sections,
      testFiles,
      generatedAt: new Date().toISOString(),
      modelUsed: modelSelection.primaryModel
    };
  }

  private static async generateReadme(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<string> {
    const prompt = `
    En tant que rédacteur technique expert, créez un fichier README.md complet et professionnel pour le projet suivant:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    Fonctionnalités: ${projectData.features.join(', ')}
    
    Le README doit inclure:
    1. Badge de statut (build, tests, couverture)
    2. Description du projet
    3. Capture d'écran ou démo
    4. Prérequis
    5. Installation
    6. Configuration des variables d'environnement
    7. Utilisation
    8. Structure du projet
    9. Tests
    10. Déploiement
    11. Contributing
    12. Licence
    
    Utilisez le format Markdown avec des emojis appropriés pour une meilleure lisibilité.
    `;

    return await aiModelService.generateCode(prompt, modelSelection);
  }

  private static async generateAPIDocumentation(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<string> {
    const prompt = `
    En tant qu'architecte API, créez une documentation API complète en format OpenAPI 3.0 pour le projet:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    Fonctionnalités: ${projectData.features.join(', ')}
    
    La documentation doit inclure:
    1. Introduction et overview
    2. Authentication (JWT, OAuth, etc.)
    3. Base URL et versioning
    4. Endpoints CRUD standards
    5. Schémas de requête/réponse
    6. Codes d'erreur
    7. Rate limiting
    8. Exemples cURL
    
    Structurez la documentation avec des sections claires et des exemples pratiques.
    `;

    return await aiModelService.generateCode(prompt, modelSelection);
  }

  private static async generateArchitectureDocumentation(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<string> {
    const prompt = `
    En tant qu'architecte système, créez une documentation d'architecture détaillée pour:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    Fonctionnalités: ${projectData.features.join(', ')}
    
    La documentation doit inclure:
    1. Vue d'ensemble de l'architecture
    2. Diagrammes de flux (ASCII art)
    3. Microservices vs Monolithique
    4. Base de données et schémas
    5. Cache et stratégie de données
    6. Sécurité
    7. Scalabilité
    8. Monitoring et logging
    9. Décisions architecturales (ADRs)
    
    Utilisez des diagrammes ASCII pour illustrer les concepts clés.
    `;

    return await aiModelService.generateCode(prompt, modelSelection);
  }

  private static async generateDeploymentDocumentation(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<string> {
    const prompt = `
    En tant qu'ingénieur DevOps, créez un guide de déploiement complet pour:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    
    Le guide doit inclure:
    1. Prérequis système
    2. Configuration Docker (Dockerfile, docker-compose.yml)
    3. Configuration environnementale
    4. Déploiement local
    5. Déploiement staging
    6. Déploiement production
    7. CI/CD pipeline (GitHub Actions)
    8. Monitoring et health checks
    9. Backup et recovery
    10. Dépannage courant
    
    Fournissez des commandes exactes et des fichiers de configuration exemples.
    `;

    return await aiModelService.generateCode(prompt, modelSelection);
  }

  private static async generateUnitTests(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<TestFile[]> {
    const prompt = `
    En tant qu'expert en tests, créez des fichiers de tests unitaires complets en utilisant Jest pour le projet:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    
    Générez des tests pour:
    1. Utils et helpers
    2. Services et controllers
    3. Models et schémas
    4. Middleware
    5. Custom hooks (si React)
    
    Chaque test doit inclure:
    - Description claire
    - Setup et teardown
    - Cas positifs et négatifs
    - Mocks appropriés
    - Assertions précises
    - Couverture des edge cases
    
    Fournissez le code complet des fichiers de tests.
    `;

    const testCode = await aiModelService.generateCode(prompt, modelSelection);
    
    // Parse the generated code into separate test files
    return [
      {
        fileName: 'utils.test.js',
        content: testCode,
        type: 'unit',
        framework: 'jest',
        coverage: 85
      },
      {
        fileName: 'services.test.js',
        content: testCode,
        type: 'unit',
        framework: 'jest',
        coverage: 90
      }
    ];
  }

  private static async generateIntegrationTests(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<TestFile[]> {
    const prompt = `
    En tant qu'expert en tests, créez des tests d'intégration en utilisant Jest et Supertest pour le projet:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    
    Générez des tests pour:
    1. Endpoints API
    2. Intégration base de données
    3. Authentication et autorisation
    4. Flux utilisateur complets
    5. Error handling
    
    Les tests doivent:
    - Utiliser une base de données de test
    - Tester les scénarios réels
    - Valider les réponses API
    - Gérer le cleanup
    - Inclure des tests de performance basiques
    `;

    const testCode = await aiModelService.generateCode(prompt, modelSelection);
    
    return [
      {
        fileName: 'api.integration.test.js',
        content: testCode,
        type: 'integration',
        framework: 'jest',
        coverage: 80
      }
    ];
  }

  private static async generateE2ETests(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<TestFile[]> {
    const prompt = `
    En tant qu'expert en tests E2E, créez des tests end-to-end en utilisant Cypress pour le projet:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Fonctionnalités: ${projectData.features.join(', ')}
    
    Générez des tests pour:
    1. Flux d'inscription/connexion
    2. Création et gestion de contenu
    3. Navigation et UX
    4. Formulaires et validation
    5. Responsive design
    6. Performance et chargement
    
    Les tests doivent:
    - Simuler des utilisateurs réels
    - Tester les workflows complets
    - Inclure des assertions visuelles
    - Gérer les états asynchrones
    - Fournir des rapports clairs
    `;

    const testCode = await aiModelService.generateCode(prompt, modelSelection);
    
    return [
      {
        fileName: 'auth.e2e.js',
        content: testCode,
        type: 'e2e',
        framework: 'cypress',
        coverage: 75
      },
      {
        fileName: 'workflows.e2e.js',
        content: testCode,
        type: 'e2e',
        framework: 'cypress',
        coverage: 70
      }
    ];
  }

  private static async generateContributingGuide(
    projectData: any,
    modelSelection: ModelSelection
  ): Promise<string> {
    const prompt = `
    En tant que maintainer open-source, créez un guide de contribution détaillé pour:
    
    Nom du projet: ${projectData.name}
    Description: ${projectData.description}
    Stack technique: ${projectData.techStack.join(', ')}
    
    Le guide doit inclure:
    1. Comment contribuer
    2. Processus de développement
    3. Standards de code
    4. Convention de commits
    5. Processus de pull request
    6. Revue de code
    7. Reporting de bugs
    8. Demande de fonctionnalités
    9. Code de conduite
    10. Licence
    
    Rédigez dans un ton accueillant et professionnel.
    `;

    return await aiModelService.generateCode(prompt, modelSelection);
  }

  static async generateTestCoverageReport(
    testFiles: TestFile[]
  ): Promise<string> {
    const totalCoverage = testFiles.reduce((sum, file) => sum + file.coverage, 0) / testFiles.length;
    const byType = {
      unit: testFiles.filter(f => f.type === 'unit').length,
      integration: testFiles.filter(f => f.type === 'integration').length,
      e2e: testFiles.filter(f => f.type === 'e2e').length
    };

    return `
# Test Coverage Report

## Summary
- **Overall Coverage**: ${totalCoverage.toFixed(1)}%
- **Total Test Files**: ${testFiles.length}
- **Unit Tests**: ${byType.unit}
- **Integration Tests**: ${byType.integration}
- **E2E Tests**: ${byType.e2e}

## Coverage by File
${testFiles.map(file => `
- **${file.fileName}**: ${file.coverage}% (${file.type} - ${file.framework})
`).join('')}

## Recommendations
${totalCoverage >= 80 ? '✅ Excellent test coverage!' : 
  totalCoverage >= 60 ? '⚠️ Good coverage, but could be improved' : 
  '❌ Test coverage needs improvement'}

## Next Steps
1. Run tests locally: \`npm test\`
2. Generate coverage report: \`npm run test:coverage\`
3. Focus on areas with low coverage
4. Add integration tests for critical paths
5. Implement E2E tests for user workflows
    `;
  }

  static exportToFiles(documentationPackage: DocumentationPackage): Record<string, string> {
    const files: Record<string, string> = {};

    // Export documentation sections
    documentationPackage.sections.forEach(section => {
      const fileName = section.title.toLowerCase().replace(/\s+/g, '-') + '.md';
      files[fileName] = section.content;
    });

    // Export test files
    documentationPackage.testFiles.forEach(testFile => {
      files[`tests/${testFile.fileName}`] = testFile.content;
    });

    // Export package.json with test scripts
    files['package.json'] = JSON.stringify({
      name: documentationPackage.project.name,
      version: documentationPackage.project.version,
      description: documentationPackage.project.description,
      scripts: {
        test: 'jest',
        'test:watch': 'jest --watch',
        'test:coverage': 'jest --coverage',
        'test:integration': 'jest --config=jest.integration.config.js',
        'test:e2e': 'cypress run',
        'cy:open': 'cypress open'
      },
      devDependencies: {
        jest: '^29.0.0',
        '@types/jest': '^29.0.0',
        'jest-environment-jsdom': '^29.0.0',
        supertest: '^6.0.0',
        cypress: '^12.0.0',
        '@cypress/vue': '^5.0.0'
      }
    }, null, 2);

    return files;
  }
}

export const documentationGenerator = DocumentationGenerator;